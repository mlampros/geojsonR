{
    "collab_server" : "",
    "contents" : "---\nlayout: post\ntitle: Text Processing using the textTinyR package\ntags: [R, package, R-bloggers]\ncomments: true\n---\n\n\n\n\nThis blog post is about my recently released package on CRAN, **textTinyR**. The following notes and examples are based mainly on the package Vignette.\n\nThe advantage of the *textTinyR* package lies in its ability to process big text data files in batches efficiently. For this purpose, it offers functions for splitting, parsing, tokenizing and creating a vocabulary. Moreover, it includes functions for building either a document-term matrix or a term-document matrix and extracting information from those (term-associations, most frequent terms). Lastly, it embodies functions for calculating token statistics (collocations, look-up tables, string dissimilarities) and functions to work with sparse matrices. The source code is based mainly on C++11 and exported in R through the Rcpp, RcppArmadillo and BH packages.\n\n<br>\n\n\n*update (06-01-2017):* On a Unix Operating System (OS) the boost library and especially the boost-locale are necessary,\n\n* **Debian OS** : sudo apt-get install libboost-all-dev\n* **Fedora OS** : yum install boost-devel\n* **Mac OS**    : brew install boost\n\n\n<br>\n\n\nThe following **classes** (based on the R6 package) and **functions** are part of the package:\n\n<br>\n\n#### **classes** \n\n\n<br>\n\n\n|    big_tokenize_transform   |   sparse_term_matrix    |  token_stats                     |  \n| :-------------------------: |  :------------------:   | :-----------------------------:  | \n|   big_text_splitter()       |  Term_Matrix()          | path_2vector()                   |\n|   big_text_parser()         |  Term_Matrix_Adjust()   | freq_distribution()              |\n|   big_text_tokenizer()      |  term_associations()    | print_frequency()                |\n|   vocabulary_accumulator()  |  most_frequent_terms()  | count_character()                |\n|                             |                         | print_count_character()          |\n|                             |                         | collocation_words()              |\n|                             |                         | print_collocations()             |\n|                             |                         | string_dissimilarity_matrix()    |\n|                             |                         | look_up_table()                  |\n|                             |                         | print_words_lookup_tbl()         |\n\n\n<br>\n  \n  \n#### **functions**\n\n\n<br>\n\n\n|    sparse_matrices       |   tokenization                   |  utilities                |  \n| :----------------------: |  :-----------------------------: | :----------------------:  | \n|   dense_2sparse()        |  tokenize_transform_text()       | bytes_converter()         |\n|   load_sparse_binary()   |  tokenize_transform_vec_docs()   | cosine_distance()         |\n|   matrix_sparsity()      |                                  | dice_distance()           |\n|   save_sparse_binary()   |                                  | levenshtein_distance()    |\n|   sparse_Means()         |                                  | read_characters()         |\n|   sparse_Sums()          |                                  | read_rows()               |\n|                          |                                  | text_file_parser()        |\n|                          |                                  | utf_locale()              |\n|                          |                                  | vocabulary_parser()       |\n\n\n\n\n<br><br>\n\n\n\n### *big_tokenize_transform* class\n\n<br>\n\nThe *big_tokenize_transform* class can be utilized to process big data files and I'll illustrate this using the [english wikipedia pages and articles](https://dumps.wikimedia.org/enwiki/latest/) (to download the data use the following web-address : https://dumps.wikimedia.org/enwiki/latest/enwiki-latest-pages-articles.xml.bz2). The size of the file (after downloading and extracting locally) is aproximalely 59.4 GB and it's of type .xml (to reproduce the results one needs to have free hard drive space of approx. 200 GB). <br> \n*Xml* files have a tree structure and one should use queries to acquire specific information. First, I'll observe the structure of the .xml file by using the utility function *read_rows()*. The *read_rows()* function takes a file as input and by specifying the *rows* argument it returns a subset of the file. It doesn't load the entire file in memory, but it just opens the file and reads the specific number of rows,\n\n<br>\n\n```R\n\n\nlibrary(textTinyR)\n\n\nPATH = 'enwiki-latest-pages-articles.xml'\n\n\nsubset = read_rows(input_file = PATH, read_delimiter = \"\\n\",\n                   \n                   rows = 100,\n                   \n                   write_2file = \"/subs_output.txt\")\n\n```\n\n\n<br>\n\n\n```R\n\n# data subset : subs_output.txt\n\n\n<mediawiki xmlns=\"http://www.mediawiki.org/xml/export-0.10/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd\" version=\"0.10\" xml:lang=\"en\">\n  <siteinfo>\n    <sitename>Wikipedia</sitename>\n    <dbname>enwiki</dbname>\n    <base>https://en.wikipedia.org/wiki/Main_Page</base>\n    <generator>MediaWiki 1.28.0-wmf.23</generator>\n    <case>first-letter</case>\n    <namespaces>\n      <namespace key=\"-2\" case=\"first-letter\">Media</namespace>\n      <namespace key=\"-1\" case=\"first-letter\">Special</namespace>\n      <namespace key=\"0\" case=\"first-letter\" />\n      <namespace key=\"1\" case=\"first-letter\">Talk</namespace>\n      <namespace key=\"2\" case=\"first-letter\">User</namespace>\n      <namespace key=\"3\" case=\"first-letter\">User talk</namespace>\n      <namespace key=\"4\" case=\"first-letter\">Wikipedia</namespace>\n      <namespace key=\"5\" case=\"first-letter\">Wikipedia talk</namespace>\n      <namespace key=\"6\" case=\"first-letter\">File</namespace>\n      <namespace key=\"7\" case=\"first-letter\">File talk</namespace>\n      <namespace key=\"8\" case=\"first-letter\">MediaWiki</namespace>\n.\n.\n.\n    </namespaces>\n  </siteinfo>\n  <page>\n    <title>AccessibleComputing</title>\n    <ns>0</ns>\n    <id>10</id>\n    <redirect title=\"Computer accessibility\" />\n    <revision>\n      <id>631144794</id>\n      <parentid>381202555</parentid>\n      <timestamp>2014-10-26T04:50:23Z</timestamp>\n      <contributor>\n        <username>Paine Ellsworth</username>\n        <id>9092818</id>\n      </contributor>\n      <comment>add [[WP:RCAT|rcat]]s</comment>\n      <model>wikitext</model>\n      <format>text/x-wiki</format>\n      <text xml:space=\"preserve\">#REDIRECT [[Computer accessibility]]\n\n{{Redr|move|from CamelCase|up}}</text>\n      <sha1>4ro7vvppa5kmm0o1egfjztzcwd0vabw</sha1>\n    </revision>\n  </page>\n  <page>\n    <title>Anarchism</title>\n    <ns>0</ns>\n    <id>12</id>\n    <revision>\n      <id>746687538</id>\n      <parentid>744318951</parentid>\n      <timestamp>2016-10-28T22:43:19Z</timestamp>\n      <contributor>\n        <username>Eduen</username>\n        <id>7527773</id>\n      </contributor>\n      <minor />\n      <comment>/* Free love */</comment>\n      <model>wikitext</model>\n      <format>text/x-wiki</format>\n      <text xml:space=\"preserve\">{{Redirect2|Anarchist|Anarchists|the fictional character|Anarchist (comics)|other uses|Anarchists (disambiguation)}}\n{{pp-move-indef}}\n\n```\n\n<br>\n\nIn that way one has a picture of the .xml tree structure and can continue by performing queries. The initial data file is too big to fit in the memory of a PC, thus it has to be split in smaller files, pre-processed and then returned as a single file. The main aim of the *big_text_splitter()* method is to split the data in smaller files of (approx.) equal size by either using the *batches* parameter or if the file has a structure by adding the *end_query* parameter too. Here I'll take advantage of both the *batches* and the *end_query* parameters for this task, because I'll use queries to extract the text tree-elements, so I don't want that the file is split arbitrarily. Each sub-element in the file begins and ends with the same key-word, i.e. text,\n\n<br>\n\n```R\n\n\nbtt = big_tokenize_transform$new(verbose = TRUE)\n\nbtt$big_text_splitter(input_path_file = PATH,             # path to the enwiki data file\n                  \n                  output_path_folder = \"/enwiki_spl_data/\",  # folder to save the files\n                  \n                  end_query = '</text>',    # splits the file taking into account the key-word\n                  \n                  batches = 40,                           # split file in 40 batches (files)\n                  \n                  trimmed_line = FALSE,                   # the lines will be trimmed\n                  \n                  verbose = TRUE)\n```\n\n\n```R\n\napprox. 10 % of data pre-processed\napprox. 20 % of data pre-processed\napprox. 30 % of data pre-processed\napprox. 40 % of data pre-processed\napprox. 50 % of data pre-processed\napprox. 60 % of data pre-processed\napprox. 70 % of data pre-processed\napprox. 80 % of data pre-processed\napprox. 90 % of data pre-processed\napprox. 100 % of data pre-processed\n\nIt took 42.7098 minutes to complete the splitting\n\n```\n\n<br>\n\nAfter the data is split and saved in the *output_path_folder* (\"/ewiki_spl_data/\") the next step is to extract the **text** tree-elements from the batches by using the *big_text_parser()* method. The latter takes as arguments the previously created *input_path_folder*, an *output_path_folder* to save the resulted text files, a *start_query*, an *end_query*, the *min_lines* (only subsets of text with more than or equal to this minimum will be kept) and the *trimmed_line* ( specifying if each line is already trimmed both-sides ),\n\n<br>\n\n```R\n\nbtt$big_text_parser(input_path_folder = \"/enwiki_spl_data/\", # the previously created folder\n                    \n                    output_path_folder = \"/enwiki_parse/\",  # folder to save the parsed files\n                    \n                    start_query = \"<text xml:space=\\\"preserve\\\">\",  # starts to extract text\n                    \n                    end_query = \"</text>\",                        # stop to extract once here\n                    \n                    min_lines = 1, \n                    \n                    trimmed_line = TRUE,\n                    \n                    verbose = TRUE)\n```\n\n\n```R\n\n====================\nbatch 1 begins ...\n====================\n\napprox. 10 % of data pre-processed\napprox. 20 % of data pre-processed\napprox. 30 % of data pre-processed\napprox. 40 % of data pre-processed\napprox. 50 % of data pre-processed\napprox. 60 % of data pre-processed\napprox. 70 % of data pre-processed\napprox. 80 % of data pre-processed\napprox. 90 % of data pre-processed\napprox. 100 % of data pre-processed\n\nIt took 0.296151 minutes to complete the preprocessing\n\nIt took 0.0525948 minutes to save the pre-processed data\n\n.\n.\n.\n.\n\n====================\nbatch 40 begins ...\n====================\n\napprox. 10 % of data pre-processed\napprox. 20 % of data pre-processed\napprox. 30 % of data pre-processed\napprox. 40 % of data pre-processed\napprox. 50 % of data pre-processed\napprox. 60 % of data pre-processed\napprox. 70 % of data pre-processed\napprox. 80 % of data pre-processed\napprox. 90 % of data pre-processed\napprox. 100 % of data pre-processed\n\nIt took 1.04127 minutes to complete the preprocessing\n\nIt took 0.0448579 minutes to save the pre-processed data\n\nIt took 40.9034 minutes to complete the parsing\n\n```\n\n<br>\n\nHere, it's worth mentioning that the *big_text_parser* is more efficient if it extracts big chunks of text, rather than one-liners. In case of one-line text queries it has to check line by line the whole file, which is inefficient especially for files equal to the enwiki size. \n\n<br>\n\nBy extracting the text chunks from the data the .xml file size reduces to (approx.) 48.9 GB. One can now continue utilizing the *big_text_tokenizer()* method in order to tokenize and transform the data. This method takes the following parameters:\n\n**batches** (each file can be further split in batches during tokenization), **to_lower** (convert to lower case), **to_upper** (convert to upper case), **utf_locale** (change utf locale depending on the language), **read_file_delimiter** (the delimiter to use for the input data, for instance a tab-delimiter or a new-line delimiter), **remove_char** (remove specific characters from the text), **remove_punctuation_string** (remove punctuation before the data is split), **remove_punctuation_vector** (remove punctuation after the data is split), **remove_numbers** (remove numbers from the data), **trim_token** (trim the tokens both-sides), **split_string** (split the string), **split_separator** (token split seprator where multiple delimiters can be used), **remove_stopwords** (remove stopwords using one of the available languages or by providing a user defined vector of words), **language** (the language of use), **min_num_char** (the minimum number of characters to keep), **max_num_char** (the maximum number of characters to keep), **stemmer** (stemming of the words using either the porter_2steemer or n-gram stemming -- those two methods will be explained in the tokenization function), **min_n_gram** (minimum n-grams), **max_n_gram** (maximum n-grams), **skip_n_gram** (skip n-gram), **skip_distance** (skip distance for n-grams), **n_gram_delimiter** (n-gram delimiter), **concat_delimiter** (concatenation of the data in case that one wants to save the file), **path_2folder** (specified folder to save the data), **stemmer_ngram** (in case of n-gram stemming the n-grams), **stemmer_gamma** (in case of n-gram stemming the gamma parameter), **stemmer_truncate** (in case of n-gram stemming the truncation parameter), **stemmer_batches** (in case of n-gram stemming the batches parameter ), **threads** (the number of cores to use in parallel ), **save_2single_file** (should the output data be saved in a single file), **increment_batch_nr** (the enumeration of the output files will start from this number), **vocabulary_path_file** (should a vocabulary be saved in a separate file). <br>\n\nMore information about those parameters can be found in the package documentation.\n\n<br>\n\nIn this blog post I'll continue using the following transformations:\n\n* conversion to lowercase\n* trim each line\n* split each line using multiple delimiters\n* remove the punctuation ( once splitting is taken place )\n* remove the numbers from the tokens\n* limit the output words to a specific number of characters\n* remove the english stopwords\n* and save both the data (to a single file) and the vocabulary files (to a folder). \n\nEach initial file will be split in additional batches to limit the memory usage during the tokenization and transformation phase, \n\n<br>\n\n\n```R\n\nbtt$big_text_tokenizer(input_path_folder = \"/enwiki_parse/\",   # the previously parsed data\n                       \n                       batches = 4,     # each single file will be split further in 4 batches\n                       \n                       to_lower = TRUE, trim_token = TRUE,\n                       \n                       split_string=TRUE, max_num_char = 100,\n                       \n                       split_separator = \" \\r\\n\\t.,;:()?!//\",\n                       \n                       remove_punctuation_vector = TRUE,\n                       \n                       remove_numbers = TRUE,\n                       \n                       remove_stopwords = TRUE,                \n                       \n                       threads = 4, \n                       \n                       save_2single_file = TRUE,      # save to a single file\n                       \n                       vocabulary_path_folder = \"/enwiki_vocab/\",  # path to vocabulary folder\n                       \n                       path_2folder=\"/enwiki_token/\",   # folder to save the transformed data\n                       \n                       verbose = TRUE)\n\n```\n\n\n```R\n\n\n====================================\ntransformation of file 1 starts ...\n====================================\n\n-------------------\nbatch 1 begins ...\n-------------------\n\ninput of the data starts ...\nconversion to lower case starts ...\nremoval of numeric values starts ...\nthe string-trim starts ...\nthe split of the character string and simultaneously the removal of the punctuation in the vector starts ...\nstop words of the english language will be used\nthe removal of stop-words starts ...\ncharacter strings with more than or equal to 1 and less than 100 characters will be kept ...\nthe vocabulary counts will be saved in: /enwiki_vocab/batch1.txt\nthe pre-processed data will be saved in a single file in: /enwiki_token/\n\n-------------------\nbatch 2 begins ...\n-------------------\n\ninput of the data starts ...\nconversion to lower case starts ...\nremoval of numeric values starts ...\nthe string-trim starts ...\nthe split of the character string and simultaneously the removal of the punctuation in the vector starts ...\nstop words of the english language will be used\nthe removal of stop-words starts ...\ncharacter strings with more than or equal to 1 and less than 100 characters will be kept ...\nthe vocabulary counts will be saved in: /enwiki_vocab/batch1.txt\nthe pre-processed data will be saved in a single file in: /enwiki_token/\n  \n.\n.\n.\n.\n\n====================================\ntransformation of file 40 starts ...\n====================================\n\n-------------------\nbatch 1 begins ...\n-------------------\n\ninput of the data starts ...\nconversion to lower case starts ...\nremoval of numeric values starts ...\nthe string-trim starts ...\nthe split of the character string and simultaneously the removal of the punctuation in the vector starts ...\nstop words of the english language will be used\nthe removal of stop-words starts ...\ncharacter strings with more than or equal to 1 and less than 100 characters will be kept ...\nthe vocabulary counts will be saved in: /enwiki_vocab/batch40.txt\nthe pre-processed data will be saved in a single file in: /enwiki_token/\n\n-------------------\nbatch 2 begins ...\n-------------------\n\ninput of the data starts ...\nconversion to lower case starts ...\nremoval of numeric values starts ...\nthe string-trim starts ...\nthe split of the character string and simultaneously the removal of the punctuation in the vector starts ...\nstop words of the english language will be used\nthe removal of stop-words starts ...\ncharacter strings with more than or equal to 1 and less than 100 characters will be kept ...\nthe vocabulary counts will be saved in: /enwiki_vocab/batch40.txt\nthe pre-processed data will be saved in a single file in: /enwiki_token/\n  \n.\n.\n.\n.\n\nIt took 111.689 minutes to complete tokenization\n\n```\n\n<br>\n\nIn total, it took approx. 195 minutes (or 3.25 hours) to pre-process (including tokenization, transformation and vocabulary extraction) the 59.4 GB of the enwiki data. <br>\n \n<br>\n\n#### *word cloud*\n\nHaving a clean single text file of all the wikipedia pages and articles one can perform many tasks. For instance, one can build a *wordcloud* (using the wordcloud package) from the accumulated words (a word of caution : the memory consumption when running the *vocabulary_accumulator* method for this kind of data size can exceed the 10 GB),\n\n<br>\n\n```R\n\ninit$vocabulary_accumulator(input_path_folder = \"/enwiki_vocab/\", \n                            \n                            vocabulary_path_file = \"/VOCAB.txt\",\n                            \n                            max_num_chars = 50)\n```\n\n\n```R\n\nvocabulary.of.batch 40 will.be.merged ...\tminutes.to.merge.sort.batches: 4.57273\n\n\tminutes.to.save.data: 0.48584\n\n```\n\n<br>\n\nThe following table shows the first rows of the vocabulary counts,\n\n<br>\n\n\n|    terms   |   frequency  |  \n| :--------: |  :---------: | \n|  lt        |   111408435L | \n|  refgt     |   49197149L  | \n|  quot      |   48688082L  |\n|  gt        |   47466149L  |\n|  user      |   32042007L  |\n|  category  |   30619748L  |\n|  www       |   25358252L  |\n|  http      |   23008243L  |\n\n\n<br>\n\nbefore plotting the wordcloud, I'll limit the vocabulary to the first 200 words,\n\n<br>\n\n```R\n\nrdr_vocab = textTinyR::read_rows(input_file = \"/VOCAB.txt\", read_delimiter = \"\\n\",\n                                 \n                                 rows = 200, \n                                 \n                                 write_2file = \"/vocab_subset_200terms.txt\") \n\n# read the reduced data \n\nvocab_sbs <- readr::read_delim(\"/vocab_subset_200terms.txt\", \"\\t\",\n                               \n                               escape_double = FALSE, col_names = FALSE, \n                               \n                               trim_ws = TRUE)\n\n# create the wordcloud\n\npal2 <- RColorBrewer::brewer.pal(8, \"Dark2\")\n\nwordcloud::wordcloud(words = vocab_sbs$X1, freq = vocab_sbs$X2, \n                     \n                     scale = c(4.5, 0.8), random.order = FALSE, \n                     \n                     rot.per = .15, colors = pal2)\n\n```\n\n<br>\n\n![Alt text](/images/Rplot_textTiny.png)\n\n \n<br>\n\n#### *word vectors*\n\nI'm currently interested in word vectors and that's why I also made R-wrappers for the [GloVe](http://nlp.stanford.edu/projects/glove/) and the [fastText](https://github.com/facebookresearch/fastText) word representation algorithms. The latter two reside in my Github account as separate repositories ([GloveR](https://github.com/mlampros/GloveR) and [fastTextR](https://github.com/mlampros/fastTextR)) and can be installed using the *install_github* function of the devtools package (devtools::install_github('mlampros/GloveR'), devtools::install_github('mlampros/fastTextR')). <br>\n\"A [word representation](http://www.iro.umontreal.ca/~lisa/pointeurs/turian-wordrepresentations-acl10.pdf) is a mathematical object associated with each word, often a vector. Each dimension's value corresponds to a feature and might even have a semantic or grammatical interpretation, so we call it a word feature. Conventionally, supervised lexicalized NLP approaches take a word and convert it to a symbolic ID, which is then transformed into a feature vector using a one-hot representation: The feature vector has the same length as the size of the vocabulary, and only one dimension is on.\" <br>\n\nCurrently, there are many resources on the web on how to use [pre-trained word vectors (embeddings) as input to neural networks](https://blog.keras.io/using-pre-trained-word-embeddings-in-a-keras-model.html).\n\nIn this blog post I'll use only the *fastTextR* word representation algorithm, however detailed documentation and system requirements on how to use either the *GloveR* or the *fastTextR* can be found in the corresponding repository. If I would train the whole data file (32.2 GB) using the *fastTextR* wrapper, it would take (approx.) 15 hours,\n\n<br>\n\n\n```R\n\nlibrary(fastTextR)\n\nskp = skipgram_cbow(input_path = \"/output_token_single_file.txt\", thread = 4, dim = 50,\n                    \n                    output_path = \"/model\", method = \"skipgram\", verbose = 2)\n\n```\n\n\n```R\n\nRead 4018M words\nNumber of words:  12827221\nNumber of labels: 0\nProgress: 0.2%  words/sec/thread: 89664  lr: 0.099841  loss: 1.055581  eta: 15h32m  14m\n\n```\n\n\n<br>\n\nthus, just for illustration purposes I'll limit the train data to approx. 1 GB of the output file,\n\n<br>\n\n```R\n\n\nreduced_data = read_characters(input_file = \"/output_token_single_file.txt\", \n                               \n                               characters = 1000000000,        # approx. 1 GB of the data\n                               \n                               write_2file = \"/reduced_single_file.txt\")\n\n\n\n\nskp = skipgram_cbow(input_path = \"/reduced_single_file.txt\",  # reduced data set\n                    \n                    output_path = \"/model\",                # saves model and word vectors\n                    \n                    dim = 50,                              # 50-dimensional word vectors\n                    \n                    method = \"skipgram\",                   # method = 'skipgram'  \n                    \n                    thread = 4, verbose = 2)\n```\n\n\n```R\n\nRead 124M words\nNumber of words:  5029370\nNumber of labels: 0\nProgress: 100.0%  words/sec/thread: 94027  lr: 0.000000  loss: 0.186674  eta: 0h0m \n\ntime to complete : 33.53577 mins \n\n```\n\n<br>\n\nthe following vector-subset is the example output of the \"model.vec\" file, which includes the 50-dimensional word vectors,\n\n<br>\n\n\n```R\n\n\nlt 0.12207 0.16117 0.4641 0.73876 0.43968 0.63911 -0.53747 0.1398 ..... \nrefgt -0.0038898 -0.13976 0.26077 0.7775 0.2228 0.28169 -0.48306 .....\nquot 0.7295 -0.12472 0.32131 0.46965 0.45363 0.85022 -0.051471 ..... \ngt 0.41287 0.26584 0.6612 0.78185 0.46692 0.74092 -0.23816 .....\ncite 0.037943 0.095684 0.62832 0.93794 0.19776 0.44592 -0.21641 .....\nwww -0.31855 0.42268 0.3875 1.5457 -0.23804 0.34022 -0.051849 ..... \nref 0.45236 -0.21766 0.6341 0.76392 0.53734 0.66976 -0.23162 .....\nhttp -0.42692 0.48637 0.28622 1.7019 -0.25739 0.25948 -0.026582 ..... \nnamequot 0.56828 -0.30782 0.45707 0.78346 0.53727 0.62445 ..... \n– -0.010281 0.25528 0.04708 0.49679 0.043934 0.33733 -0.42706 .....\namp 0.06308 0.11968 0.11885 0.67699 -0.11448 0.25183 -0.48789 .....\ncategory -1.5705 -0.40638 0.61064 2.5691 -0.52987 0.68096 .....\ncounty -0.85743 0.071625 -0.43393 0.17157 -0.32874 1.771 ..... \norg -0.26974 0.76983 0.57599 1.5939 -0.1706 0.21937 -0.44645 .....\nstates -0.40973 -0.48528 0.092905 0.011603 -0.035727 0.52807 .....\nunited -0.25079 -0.49813 0.070942 0.16762 0.069961 0.56868 .....\nweb -0.066578 0.14837 0.23088 1.2919 -0.252 0.31441 -0.3799 ..... \ncensus -0.29033 -0.73695 0.35474 -0.5237 -0.15206 1.7089 .....\n.\n.\n.\n```\n\n\n<br>\n\n### *sparse_term_matrix* class\n\n<br>\n\nThe *sparse_term_matrix* class includes methods for building a document-term or a term-document matrix and extracting information from those matrices (it relies on RcppArmadillo and can handle large sparse matrices too). I'll explain all the different methods using a toy text file downloaded from wikipedia,\n\n<br>\n\n```R\n\nThe term planet is ancient, with ties to history, astrology, science, mythology, and religion. Several planets in the Solar System can be seen with the naked eye. These were regarded by many early cultures as divine, or as emissaries of deities. As scientific knowledge advanced, human perception of the planets changed, incorporating a number of disparate objects. In 2006, the International Astronomical Union (IAU) officially adopted a resolution defining planets within the Solar System. This definition is controversial because it excludes many objects of planetary mass based on where or what they orbit. \nAlthough eight of the planetary bodies discovered before 1950 remain planets under the modern definition, some celestial bodies, such as Ceres, Pallas, Juno and Vesta (each an object in the solar asteroid belt), and Pluto (the first trans-Neptunian object discovered), that were once considered planets by the scientific community, are no longer viewed as such.\nThe planets were thought by Ptolemy to orbit Earth in deferent and epicycle motions. Although the idea that the planets orbited the Sun had been suggested many times, it was not until the 17th century that this view was supported by evidence from the first telescopic astronomical observations, performed by Galileo Galilei. \nAt about the same time, by careful analysis of pre-telescopic observation data collected by Tycho Brahe, Johannes Kepler found the planets orbits were not circular but elliptical. As observational tools improved, astronomers saw that, like Earth, the planets rotated around tilted axes, and some shared such features as ice caps and seasons. Since the dawn of the Space Age, close observation by space probes has found that Earth and the other planets share characteristics such as volcanism, hurricanes, tectonics, and even hydrology.\nPlanets are generally divided into two main types: large low-density giant planets, and smaller rocky terrestrials. Under IAU definitions, there are eight planets in the Solar System. In order of increasing distance from the Sun, they are the four terrestrials, Mercury, Venus, Earth, and Mars, then the four giant planets, Jupiter, Saturn, Uranus, and Neptune. Six of the planets are orbited by one or more natural satellites.\n\n```\n\n<br>\n\nThe *sparse_term_matrix* class can be initialized using either a vector of documents or a text file. Assuming the downloaded file is saved as \"planets.txt\", then a document-term-matrix can be created in the following way,\n\n<br>\n\n```R\n\ninit = sparse_term_matrix$new(vector_data = NULL,          # in case of vector of documents\n                              \n                              file_data = \"/planets.txt\",     # input the .txt data\n                              \n                              document_term_matrix = TRUE)   # document term matrix as output\n\n\n\ntm = init$Term_Matrix(sort_terms = TRUE,      # initial terms are sorted\n                 \n                      to_lower = TRUE,          # convert to lower case\n                 \n                      trim_token = TRUE,        # trim token\n                 \n                      split_string = TRUE,      # split string\n                 \n                      tf_idf = TRUE,            # tf-idf will be returned\n                      \n                      verbose = TRUE)\n\n```\n\n\n```R\n\nminutes.to.tokenize.transform.data: 0.00001\ttotal.time: 0.00001\n\nWarning message:\nempty character strings present in the column names they will be replaced with proper characters \n\n\n5 x 214 sparse Matrix of class \"dgCMatrix\"\n   [[ suppressing 214 column names 'X', 'X.planets.', 'X17th' ... ]]\n\n[1,] -0.001939591 .          .        .          0.00974777 0.0194955  . . . . .         \n[2,] -0.003255742 0.0163623  .         0.0163623 .           .         . . . . .  \n[3,] -0.003440029 .          0.017288 .          .           .         . . . . . \n[4,] -0.002196645 .          .        .          .           .         . . . . . \n[5,] -0.002681199 .          .        .          .           .         . . . . .                                                                                                  \n\n\n\n```\n\n<br>\n\nThe *Term_Matrix* method takes almost the same parameters as the ( already explained ) *big_text_tokenizer()* method. The only differences are: \n\n* **sort_terms** ( should the output terms - rows or columns depending on the *document_term_matrix* parameter - be sorted in alphabetical order )\n* **print_every_rows** ( verbose output intervalls )\n* **normalize** ( applies *l1* or *l2* normalization )\n* **tf_idf** ( the term-frequency-inverse-document-frequency will be returned )\n\nDetails about the parameters of the *Term_Matrix* method can be found in the package documentation. <br>\n\n<br> \n\nTo adjust the sparsity of the output matrix one can take advantage of the *Term_Matrix_Adjust* method, (by adjusting the *sparsity_thresh* parameter towards 0.0 a proportion of the sparse terms will be removed)\n\n<br>\n\n```R\n\ninit$Term_Matrix_Adjust(sparsity_thresh = 0.6)             # terms (here columns) which sum to zero will be removed\n\n```\n\n\n```R\n\n5 x 9 sparse Matrix of class \"dgCMatrix\"\n          planets           by            X       solar          and          as         the        that  earth\n[1,] -0.005818773 -0.001939591 -0.001939591 0.004747735 -0.001939591 0.007121603 -0.01163755 .           .          \n[2,] -0.006511484 -0.003255742 -0.003255742 0.003984706 -0.006511484 0.007969413 -0.01627871 0.003984706 .          \n[3,] -0.006880059 -0.010320088 -0.003440029 .           -0.003440029 .           -0.02064018 0.008420511 0.00421\n[4,] -0.006589936 -0.006589936 -0.002196645 .           -0.008786581 0.008065430 -0.01317987 0.005376953 0.00537\n[5,] -0.013405997 -0.002681199 -0.002681199 0.003281523 -0.008043598 .           -0.01340600 .           0.00328\n\n\n````\n\n<br>\n\nThe *term_associations* method returns the correlation of specific terms (*Terms*) with all the other terms in the output matrix. In case that one of the terms is not present in the corpus then a warning will be printed in the console, \n\n<br>\n\n```R\n\ninit$term_associations(Terms = c('giant', 'terrestrials', 'INVALID'), keep_terms = NULL, verbose = TRUE)\n\n```\n\n\n```R\n\nthe ' INVALID ' term does not exist in the terms vector \n\ntotal.number.variables.processed:   2\tminutes.to.complete: 0.00002\n\n\n$giant\n         term correlation\n  1:     then   1.0000000\n  2:      two   1.0000000\n  3:  divided   1.0000000\n  4: distance   1.0000000\n  5:    rocky   1.0000000\n ---                     \n209:       to  -0.4082483\n210:     that  -0.5590170\n211:       as  -0.5897678\n212:      the  -0.6123724\n213:     were  -1.0000000\n\n\n$terrestrials\n             term correlation\n  1:        there   1.0000000\n  2:      jupiter   1.0000000\n  3:          two   1.0000000\n  4:      neptune   1.0000000\n  5:        rocky   1.0000000\n ---                         \n209: astronomical  -0.4082483\n210:         that  -0.5590170\n211:           as  -0.5897678\n212:          the  -0.6123724\n213:         were  -1.0000000\n\n```\n\n\n<br>\n\nLastly, the *most_frequent_terms* method gives the frequency of the terms in the corpus. However, the function returns only if the *normalize* parameter is NULL and the *tf_idf* parameter is FALSE ( the latter two parameters belong to the *init$Term_Matrix()* method ),\n\n<br>\n\n\n```R\n\ninit$most_frequent_terms(keep_terms = 10, threads = 1, verbose = TRUE)\n\nminutes.to.complete: 0.00000\n\n       term frequency\n 1:     the        28\n 2: planets        13\n 3:     and        11\n 4:      by         9\n 5:      of         9\n 6:      as         8\n 7:     in.         6\n 8:       X         5\n 9:    that         5\n10:     are         5\n\n```\n\n<br>\n\nMore information about the *sparse_term_matrix* class can be found in the package documentation.\n\n<br>\n\n### *token_stats* class\n\n<br>\n\nThe *token_stats* class can be utilized to output corpus statistics. Each of the following methods can take either a *vector of terms*, a *text file* or *a folder of files* as input:\n\n<br>\n\n* **path_2vector** : is a helper method which takes a path to a file or folder of files and returns the content in form of a vector, <br>\n\n```R\n\ninit = token_stats$new(path_2file = \"/planets.txt\")    # input the 'planets.txt' file\n\nvec = init$path_2vector()\n \n```\n\n\n```R\n\n[1] \"The term planet is ancient, with ties to history, astrology, science, mythology, and religion. Several planets in the Solar System can be seen with the naked eye. These were regarded by many early cultures as divine, or as emissaries of deities. As scientific knowledge advanced, human perception of the planets changed, incorporating a number of disparate objects\" ....\n\n[2] \"Although eight of the planetary bodies discovered before 1950 remain\" ....\n.\n.\n\n```\n\n<br>\n\n* **freq_distribution** : it returns a named-unsorted vector frequency distribution for a vocabulary file\n\n```R\n\n# assuming the following 'freq_vocab.txt'\n\nthe\nterm\nplanet\nis\nancient\nwith\nties\nto\nhistory\nastrology\nscience\nmythology\nand\nreligion\nseveral\nplanets\nin\nthe\nsolar\nsystem\ncan\nbe\nseen\nwith\nthe\nnaked\neye\nthese\nwere\n\n```\n\n<br>\n\nthis method would return,\n\n<br>\n\n```R\n\ninit = token_stats$new(path_2file = 'freq_vocab.txt')\n\ninit$freq_distribution()\n\ninit$print_frequency(subset = NULL)\n\n```\n\n\n```R\n        words freq\n 1:       the    3\n 2:      with    2\n 3:   ancient    1\n 4:       and    1\n 5: astrology    1\n 6:        be    1\n 7:       can    1\n 8:       eye    1\n 9:   history    1\n10:        in    1\n11:        is    1\n12: mythology    1\n13:     naked    1\n14:    planet    1\n15:   planets    1\n16:  religion    1\n17:   science    1\n18:      seen    1\n19:   several    1\n20:     solar    1\n21:    system    1\n22:      term    1\n23:     these    1\n24:      ties    1\n25:        to    1\n26:      were    1\n        words freq\n\n```\n\n<br>\n\n* **count_character** : it returns the number of characters for each word of the corpus. \n\n<br>\n\nfor the previously mentioned *'freq_vocab.txt'* it would output,\n\n<br>\n\n```R\n\n  init = token_stats$new(path_2file = 'freq_vocab.txt')\n\n  vec_tmp = init$count_character()\n  \n  init$print_count_character(number = 3)\n\n```\n\n\n```R\n\n# words with number of characters equal to 3\n\n[1] \"the\" \"and\" \"the\" \"can\" \"the\" \"eye\"\n\n```\n\n<br>\n\n* **collocation_words** : it returns a co-occurence frequency table for n-grams. \"A [collocation]( http://nlp.stanford.edu/fsnlp/promo/colloc.pdf) is defined as a sequence of two or more consecutive words, that has characteristics of a syntactic and semantic unit, and whose exact and unambiguous meaning or connotation cannot be derived directly from the meaning or connotation of its components\". The input to the function should be text n-grams separated by a delimiter ( for instance the *tokenize_transform_text()* function in the next code chunk will build n_grams of length 3 ),\n\n<br>\n\n```R\n\n# the data needs to be n-grams thus first tokenize and build the n-grams using \n# the 'tokenize_transform_text' function ( the \"planets.txt\" file as input )\n\ntok = tokenize_transform_text(\"planets.txt\",  \n                              \n                              to_lower = T, \n                              \n                              split_string = T,\n                              \n                              min_n_gram = 3, \n                              \n                              max_n_gram = 3, \n                              \n                              n_gram_delimiter = \"_\")\n\ninit = token_stats$new(x_vec = tok$token)      # vector data as input\n\nvec_tmp = init$collocation_words()\n\n```\n\n<br>\n\nthe example output of the *vec_tmp* vector is,\n\n<br>\n\n```R\n\n[1] \"\"       \"17th\"       \"1950\"    \"2006\"    \"a\"     \"about\"   \"adopted\"   \"advanced\"       \n[9] \"age\"    \"although\" ....  \n.\n.\n.\n\n```\n\n<br>\n\nand the *print_collocations* method returns the coolocations for the example word *ancient*,\n\n<br>\n\n```R\n\nres = init$print_collocations(word = \"ancient\")\n\n```\n\n\n\n```R\n\n    is   with   ties planet \n 0.333  0.333  0.167  0.167 \n\n```\n\n<br>\n\n* **string_dissimilarity_matrix** : it returns a string-dissimilarity-matrix using either the *dice*, *levenshtein* or *cosine distance*. The input can be a *character string vector* only. In case that the method is dice then the dice-coefficient (similarity) is calculated between two strings for a specific number of character n-grams ( dice_n_gram ). The *dice* and *levenshtein* methods are applied to words, whereas the *cosine* distance to word-sentences.\n\n<br>\n\nFor illustration purposes I'll use the previously mentioned *'freq_vocab.txt'* file, but first I have to convert the text file to a character vector,\n\n<br>\n\n```R\n\n# first initialization of token_stats \n\ninit = token_stats$new(path_2file = 'freq_vocab.txt')\n\ntmp_vec = init$path_2vector()      # convert to vector\n\n\n# second initialization to compute the dissimilarity matrix \n\ninit_tok = token_stats$new(x_vec = tmp_vec)\n\nres = init_tok$string_dissimilarity_matrix(dice_n_gram = 2, method = \"dice\", \n                                         \n                                          split_separator = \" \", dice_thresh = 1.0, \n                                         \n                                          upper = TRUE, diagonal = TRUE, threads = 1)\n\n```\n\n\n```R\n\n                the      term     planet is   ancient      with      ties to   history  ....\nthe       0.0000000 0.6000000 1.00000000  1 1.0000000 1.0000000 0.6000000  1 1.0000000  ....\nterm      0.6000000 0.0000000 1.00000000  1 1.0000000 1.0000000 0.6666667  1 1.0000000  ....\nplanet    1.0000000 1.0000000 0.00000000  1 0.8181818 1.0000000 1.0000000  1 1.0000000  ....\nis        1.0000000 1.0000000 1.00000000  0 1.0000000 1.0000000 1.0000000  0 1.0000000  ....\nancient   1.0000000 1.0000000 0.81818182  1 0.0000000 1.0000000 0.7777778  1 1.0000000  ....\nwith      1.0000000 1.0000000 1.00000000  1 1.0000000 0.0000000 1.0000000  1 1.0000000  ....\nties      0.6000000 0.6666667 1.00000000  1 0.7777778 1.0000000 0.0000000  1 1.0000000  ....\nto        1.0000000 1.0000000 1.00000000  0 1.0000000 1.0000000 1.0000000  0 1.0000000  ....\nhistory   1.0000000 1.0000000 1.00000000  1 1.0000000 1.0000000 1.0000000  1 0.0000000  ....\nastrology 1.0000000 1.0000000 1.00000000  1 0.8571429 1.0000000 1.0000000  1 0.8571429  ....\nscience   1.0000000 1.0000000 1.00000000  1 0.3333333 1.0000000 0.7777778  1 1.0000000  ....\n.\n.\n.\n```\n\n<br>\n\nhere by adjusting (reducing ) the *dice_thresh* parameter we can force values close to 1.0 to become 1.0,\n\n<br>\n\n```R\n\n                the term     planet is   ancient with ties to history astrology   science ....\nthe       0.0000000    1 1.00000000  1 1.0000000    1    1  1       1         1 1.0000000 ....\nterm      1.0000000    0 1.00000000  1 1.0000000    1    1  1       1         1 1.0000000 ....\nplanet    1.0000000    1 0.00000000  1 1.0000000    1    1  1       1         1 1.0000000 ....\nis        1.0000000    1 1.00000000  0 1.0000000    1    1  0       1         1 1.0000000 ....\nancient   1.0000000    1 1.00000000  1 0.0000000    1    1  1       1         1 0.3333333 ....\nwith      1.0000000    1 1.00000000  1 1.0000000    0    1  1       1         1 1.0000000 ....\nties      1.0000000    1 1.00000000  1 1.0000000    1    0  1       1         1 1.0000000 ....\nto        1.0000000    1 1.00000000  0 1.0000000    1    1  0       1         1 1.0000000 ....\nhistory   1.0000000    1 1.00000000  1 1.0000000    1    1  1       0         1 1.0000000 ....\nastrology 1.0000000    1 1.00000000  1 1.0000000    1    1  1       1         0 1.0000000 ....\nscience   1.0000000    1 1.00000000  1 0.3333333    1    1  1       1         1 0.0000000 .... \n.\n.\n.\n```\n\n<br>\n\n* **look_up_table** : The idea here is to split the input words to n-grams using a numeric value and then retrieve the words which have a similar character n-gram. <br>\nIt returns a look-up-list where the list-names are the n-grams and the list-vectors are the words associated with those n-grams. The words for each n-gram can be retrieved using the *print_words_lookup_tbl* method. The input can be a character string vector only.\n\n<br>\n\n```R\n\n# first initialization of token_stats \n\ninit = token_stats$new(path_2file = 'freq_vocab.txt')\n\ntmp_vec = init$path_2vector()    # convert to vector\n\n\n# second initialization to compute the look-up-table\n\ninit_lk = token_stats$new(x_vec = tmp_vec)\n\nis_vec = init_lk$look_up_table(n_grams = 3)\n\n\n```\n\n\n\n```R\n\n# example output for the 'is_vec' vector\n\n[1] \"\"    \"ake\" \"_an\" \"anc\" \"ane\" \"_as\" \"ast\" \"cie\" \"eli\" \"enc\" \"era\" \"eve\" ..... \n[29] \"net\" \"ola\" \"olo\" \"_pl\" \"pla\" \"_re\" \"rel\" \"rol\" \"_sc\" \"sci\" \"_se\" \"see\" .....\n[57] \"tro\" \"ver\" \"_we\" \"wer\" \"_wi\" \"wit\" \"yst\" \"yth\"\n\n\n```\n\n<br>\n\nthen retrieve words with same n-grams,\n\n<br>\n\n```R\n\ninit_lk$print_words_lookup_tbl(n_gram = \"log\")\n\n```\n\n\n```R\n\n\"_astrology_\" \"_mythology_\"\n\n```\n\n<br>\n\nthe underscores are necessary to distinguish the begin and end of each word when computing the n-grams.\n\nMore information about the *token_stats* class can be found in the package documentation.\n\n<br><br>\n\n\n\n### *helper functions for sparse_matrices*\n\n<br>\n\nThe purpose of creating those functions is because I observed that they return faster in comparison to other R packages. The following code chunks explain each one of the functions,\n\n<br>\n\n```R\n\n#---------------------------------\n# conversion from dense to sparse\n#---------------------------------\n\nlibrary(textTinyR)\n\nset.seed(1)\ndsm = matrix(sample(0:1, 100, replace = T), 10, 10)\n\nres_sp = dense_2sparse(dsm)\n\nres_sp\n\n```\n\n```R\n\n## 10 x 10 sparse Matrix of class \"dgCMatrix\"\n##                          \n##  [1,] . . 1 . 1 . 1 . . .\n##  [2,] . . . 1 1 1 . 1 1 .\n##  [3,] 1 1 1 . 1 . . . . 1\n##  [4,] 1 . . . 1 . . . . 1\n##  [5,] . 1 . 1 1 . 1 . 1 1\n##  [6,] 1 . . 1 1 . . 1 . 1\n##  [7,] 1 1 . 1 . . . 1 1 .\n##  [8,] 1 1 . . . 1 1 . . .\n##  [9,] 1 . 1 1 1 1 . 1 . 1\n## [10,] . 1 . . 1 . 1 1 . 1\n\n```\n\n<br>\n\n```R\n\n#-------------\n# column- sums\n#-------------\n\nsm_cols = sparse_Sums(res_sp, rowSums = FALSE)\n\nsm_cols\n\n```\n\n```R\n\n##  [1] 6 5 3 5 8 3 4 5 3 6\n\n```\n\n<br>\n\n```R\n\n#----------\n# row-sums\n#----------\n\nsm_rows = sparse_Sums(res_sp, rowSums = TRUE)\n\nsm_rows\n\n```\n\n```R\n\n##  [1] 3 5 5 3 6 5 5 4 7 5\n\n```\n\n\n<br>\n\n```R\n\n#---------------\n# column- means\n#---------------\n\nmn_cols = sparse_Means(res_sp, rowMeans = FALSE)\n\nmn_cols\n\n```\n\n\n```R\n\n##  [1] 0.6 0.5 0.3 0.5 0.8 0.3 0.4 0.5 0.3 0.6\n\n```\n\n<br>\n\n```R\n\n#-----------\n# row-means\n#-----------\n\nmn_rows = sparse_Means(res_sp, rowMeans = TRUE)\n\nmn_rows\n\n```\n\n```R\n\n##  [1] 0.3 0.5 0.5 0.3 0.6 0.5 0.5 0.4 0.7 0.5\n\n```\n\n<br>\n\n```R\n\n#-------------------------------------\n# sparsity of a matrix (as percentage)\n#-------------------------------------\n\nmatrix_sparsity(res_sp)\n\n```\n\n```R\n\n## 51.9999 %\n\n```\n<br>\n\n```R\n\n#------------------------------------------------------\n# saving and loading sparse matrices (in binary format)\n#------------------------------------------------------\n\nsave_sp = save_sparse_binary(res_sp, file_name = \"save_sparse.mat\")\n\nload_sp = load_sparse_binary(file_name = \"save_sparse.mat\")\n\n```\n\n<br>\n\nMore information about the helper functions for sparse matrices can be found in the package documentation.\n\n<br><br>\n\n\n\n### *tokenization*\n\n<br>\n\nThe **tokenize_transform_text()** function applies tokenization and transformation in a similar way to the *big_text_tokenizer()* method, however for small to medium data sets. The input can be either a character string (text data) or a path to a file. This method takes as input a single character string (character-string == of length one). The parameters for the *tokenize_transform_text()* function are the same to the (already explained) *big_text_tokenizer()* method with the only exception being the input data type.\n\n<br>\n\nThe **tokenize_transform_vec_docs()** function works in the same way to the *Term_Matrix()* method and it targets small to medium data sets. It takes as input a vector of documents and retains their order after tokenization and transformation has taken place. Both the *tokenize_transform_text()* and *tokenize_transform_vec_docs()* share the same parameters, with the following two exceptions,\n\n* the **object** is a character vector\n* the **as_token** parameter : if TRUE then the output of the function is a list of (split) token. Otherwise it's a vector of character strings (sentences)\n\n<br>\n\nThe following code chunks give an overview of the mentioned functions,\n\n<br>\n\n\n```R\n\n#------------------------\n# tokenize_transform_text\n#------------------------\n\n\n# example input : \"planets.txt\"\n\n\nres_txt = tokenize_transform_text(object = \"/planets.txt\", \n                                  \n                                  to_lower = TRUE,\n                                  \n                                  utf_locale = \"\",           \n                                  \n                                  trim_token = TRUE,\n                                  \n                                  split_string = TRUE,\n                                  \n                                  remove_stopwords = TRUE, \n                                  \n                                  language = \"english\",\n                                  \n                                  stemmer = \"porter2_stemmer\", \n                                  \n                                  threads = 1,\n                                  \n                                  verbose = TRUE)\n\n\n\n\n```\n\n\n<br>\n\nthe output is a vector of *tokens* after the english stopwords were removed and the terms were stemmed (*porter2-stemming*),\n\n<br>\n\n```R\n\n# example output :\n\n$token\n  [1] \"term\"            \"planet\"          \"ancient\"         \"tie\"           \"histori\"  ...\n\n  [9] \"religion\"        \"planet\"          \"solar\"           \"system\"        \"nake\"     ....\n\n  [17] \"cultur\"          \"divin\"           \"emissari\"        \"deiti\"         \"scientif\" ...  \n\n  [25] \"percept\"         \"planet\"          \"chang\"           \"incorpor\"      \"number\" .....\n.\n.\n.\n\nattr(,\"class\")\n[1] \"tokenization and transformation\"\n\n\n```\n\n<br>\n\n```R\n\n#----------------------------\n# tokenize_transform_vec_docs\n#----------------------------\n\n\n# the input should be a vector of documents\n\ninit = token_stats$new(path_2file = \"/planets.txt\")\n\ninp = init$path_2vector()   # convert text file to character vector\n\n\n# run the function using the input-vector\n\nres_dct = tokenize_transform_vec_docs(object = inp, \n                                      \n                                      as_token = FALSE,  # return character vector of documents\n                                      \n                                      to_lower = TRUE,\n                                  \n                                      utf_locale = \"\",           \n                                      \n                                      trim_token = TRUE,\n                                      \n                                      split_string = TRUE,\n                                      \n                                      remove_stopwords = TRUE, \n                                      \n                                      language = \"english\",\n                                      \n                                      stemmer = \"ngram_sequential\",\n                                      \n                                      stemmer_ngram = 3,\n                                      \n                                      threads = 1,\n                                      \n                                      verbose = TRUE)\n\n\n\n```\n\n<br>\n\nthe output is a vector of *transformed documents* after the english stopwords were removed and the terms were stemmed (*ngram_sequential* of length 3),\n\n<br>\n\n```R\n\n$token\n[1] \"term planet anci ties hist astro scien mythol relig planet solar system naked eye .....\"\n\n[2] \"planet bodies discove 1950 remain \\\"plane modern definit celest bodies ceres .....\"\n\n[3] \"plan thou ptol orbit earth defer epicy moti idea plan orbit sun sugges times .....\"\n\n[4] \"time care analy pre-telesco observat data collec tycho brahe johan kepler  .....\"\n\n[5] \"plan genera divi main types large low-dens giant plan smal rocky terrestri .....\"\n\n\nattr(,\"class\")\n[1] \"tokenization and transformation\"\n\n```\n\n<br>\n\nThe documents can be returned as a list of character vectors by specifying, *as_token* = TRUE,\n\n<br>\n\n```R\n\n\n# run the function using the input-vector\n\nres_dct_tok = tokenize_transform_vec_docs(object = inp, \n                                      \n                                          as_token = TRUE,\n                                          \n                                          to_lower = TRUE,\n                                      \n                                          utf_locale = \"\",           \n                                          \n                                          trim_token = TRUE,\n                                          \n                                          split_string = TRUE,\n                                          \n                                          remove_stopwords = TRUE, \n                                          \n                                          language = \"english\",\n                                          \n                                          stemmer = \"ngram_sequential\",\n                                          \n                                          stemmer_ngram = 3,\n                                          \n                                          threads = 1,\n                                          \n                                          verbose = TRUE)\n\n\n\n```\n\n<br>\n\n```R\n\n$token\n$token[[1]]\n [1] \"term\"       \"planet\"     \"anci\"       \"ties\"       \"hist\"       ..... \n\n$token[[2]]\n [1] \"planet\"       \"bodies\"       \"discove\"      \"1950\"               .....    \n\n$token[[3]]\n [1] \"plan\"      \"thou\"      \"ptol\"      \"orbit\"     \"earth\"           .....   \n\n\nattr(,\"class\")\n[1] \"tokenization and transformation\"\n```\n\n<br>\n\nA few words about the **utf_locale**, **remove_stopwords** and **stemmer** parameters.\n\n<br>\n\n* The **utf_locale** can take as input either an empty string (\"\") or a character string (for instance \"el_GR.UTF-8\"). It should be a non-empty string if the text input is other than english. However, currently for the windows OS only english character strings or files can be input and pre-processed.\n\n<br>\n\n* The **remove_stopwords** parameter can be either a boolean (TRUE, FALSE) or a character vector of user defined stop-words. The available languages are specified by the parameter **language**. Currently, there is no support for chinese, japanese, korean, thai or languages with ambiguous word boundaries.\n\n<br>\n\n* The **stemmer** parameter can take as input one of the **porter2_stemmer**, **ngram_sequential** or **ngram_overlap**. \n    + The [*porter2_stemmer*](https://github.com/smassung/porter2_stemmer) is a C++ implementation of the [snowball-porter2](http://snowball.tartarus.org/algorithms/english/stemmer.html) stemming algorithm. \n    + On the other hand, *n-gram stemming* is *\"language independent\"* and supported by the **ngram_sequential** and **ngram_overlap** functions.\n        - [*ngram_overlap*](http://clef.isti.cnr.it/2007/working_notes/mcnameeCLEF2007.pdf) : The ngram_overlap stemming method is based on N-Gram Morphemes for Retrieval, Paul McNamee and James Mayfield\n        - [*ngram_sequential*](https://arxiv.org/pdf/1312.4824.pdf) : The ngram_sequential stemming method is a modified version based on Generation, Implementation and Appraisal of an N-gram based Stemming Algorithm, B. P. Pande, Pawan Tamta, H. S. Dhami\n\n\n<br><br>\n\n\n\n### *utility* functions\n\n<br>\n\nThe following code chunks illustrate the *utility functions* of the package (besides the **read_characters()** and **read_rows()** which used in the previous code chunks),\n\n<br>\n\n```R\n\n#---------------------------------------\n# cosine distance between word sentences\n#---------------------------------------\n\ns1 = 'sentence with two words'\n\ns2 = 'sentence with three words'\n\nsep = \" \"\n\ncosine_distance(s1, s2, split_separator = sep)\n\n```\n\n```R\n\n## [1] 0.75\n\n```\n\n\n<br>\n\n```R\n\n#------------------------------------------------------------------------\n# dice distance between two words (using n-grams -- the lower the better)\n#------------------------------------------------------------------------\n\nw1 = 'word_one'\n\nw2 = 'word_two'\n\nn = 2\n\ndice_distance(w1, w2, n_grams = n)\n\n\n```\n\n\n```R\n\n## [1] 0.2857143\n\n```\n\n<br>\n\n```R\n\n#---------------------------------------\n# levenshtein distance between two words\n#---------------------------------------\n\nw1 = 'word_two'\n\nw2 = 'word_one'\n\nlevenshtein_distance(w1, w2)\n\n```\n\n```R\n\n## [1] 3\n\n```\n\n<br>\n\n```R\n\n#---------------------------------------------\n# bytes converter (returns the size of a file)\n#---------------------------------------------\n\nPATH = \"/planets.txt\"\n\nbytes_converter(input_path_file = PATH, unit = \"KB\" )\n\n```\n\n\n```R\n\n## [1] 2.213867\n\n```\n<br>\n\n```R\n\n#---------------------------------------------------\n# returns the utf-locale for the available languages\n#---------------------------------------------------\n\n\nutf_locale(language = \"english\")\n\n```\n\n```R\n\n## [1] \"en.UTF-8\"\n\n```\n\n<br>\n\n```R\n\n#-----------------\n# text file parser\n#-----------------\n\n# The text file should have a structure (such as an xml-structure), so that \n# subsets can be extracted using the \"start_query\" and \"end_query\" parameters.\n# (it works similarly to the big_text_parser() method, however for small to medium sized files)\n\n# example input \"example_file.xml\" file :\n\n<?xml version=\"1.0\"?>\n<sked>\n  <version>2</version>\n  <flight>\n    <carrier>BA</carrier>\n    <number>4001</number>\n    <date>2011-07-21</date>\n  </flight>\n  <flight cancelled=\"true\">\n    <carrier>BA</carrier>\n    <number>4002</number>\n    <date>2011-07-21</date>\n  </flight>\n</sked>\n\n\n\n```\n\n<br>\n\n```R\n\nfp = text_file_parser(input_path_file = \"example_file.xml\", \n                      \n                      output_path_file = \"/output_folder/example_output_file.txt\", \n                      \n                      start_query = '<number>', end_query = '</number>',\n                      \n                      min_lines = 1, trimmed_line = FALSE)\n\n```\n\n\n```R\n\n\"example_output_file.txt\" :\n  \n4001\n4002\n\n```\n\n<br>\n\n```R\n\n#------------------\n# vocabulary parser\n#------------------\n\n# the 'vocabulary_parser' function extracts a vocabulary from a structured text (such as \n# an .xml file) and works in the exact same way as the 'big_tokenize_transform' class, \n# however for small to medium sized data files\n\n\npars_dat = vocabulary_parser(input_path_file = '/folder/input_data.txt',\n                             \n                             start_query = 'start_word', end_query = 'end_word',\n                             \n                             vocabulary_path_file = '/folder/vocab.txt', \n                             \n                             to_lower = TRUE, split_string = TRUE,\n                             \n                             remove_stopwords = TRUE)\n\n\n```\n\n<br>\n\nAn updated version of the textTinyR package can be found in my [Github repository](https://github.com/mlampros/textTinyR) and to report bugs/issues please use the following link, [https://github.com/mlampros/textTinyR/issues](https://github.com/mlampros/textTinyR/issues).\n\n\n<br>\n",
    "created" : 1490711687205.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4239044428",
    "id" : "330BBE89",
    "lastKnownWriteTime" : 1484065220,
    "last_content_update" : 1484065220,
    "path" : "~/Downloads/2017-01-05-textTinyR_package.md",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "markdown"
}