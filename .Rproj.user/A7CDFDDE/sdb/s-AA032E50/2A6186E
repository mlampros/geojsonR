{
    "collab_server" : "",
    "contents" : "\n\n#' reads GeoJson data\n#'\n#' @param url_file_string a string specifying the input path to a file OR a geojson object (in form of a character string) OR a valid url (beginning with 'http..') pointing to a geojson object\n#' @param ... See details for the \\emph{ellipsis} (...).\n#' @return a (nested) list\n#' @details\n#' The \\emph{FROM_GeoJson} function can take two more parameters : \\emph{flatten_coords} and \\emph{average_coordinates}. Both parameters are boolean.\n#' If \\emph{flatten_coords} is TRUE then the properties member of the geojson file will be omitted. If \\emph{average_coordinates} is TRUE then additionally a geojson-dump and the average\n#' latitude and longitude of the geometry object will be returned.\n#' @export\n#' @examples\n#'\n#' library(geojsonR)\n#'\n#'\n#' # INPUT IS A FILE\n#'\n#' # Do not run\n#'\n#' # res = FROM_GeoJson(url_file_string = \"/myfolder/feature_collection.geojson\")\n#'\n#'\n#' # INPUT IS A GEOJSON (character string)\n#'\n#' tmp_str = '{ \"type\": \"MultiPolygon\", \"coordinates\": [\n#'   [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],\n#'   [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],\n#'    [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]\n#'   ]\n#' }'\n#'\n#' res = FROM_GeoJson(url_file_string = tmp_str)\n#'\n#'\n#' # INPUT IS A URL\n#'\n#' # Do not run\n#'\n#' # res = FROM_GeoJson(url_file_string = \"http://www.EXAMPLE_web_page.geojson\")\n#'\n\nFROM_GeoJson = function(url_file_string, ...) {\n\n  if (!inherits(url_file_string, 'character') && length(url_file_string) != 1) {\n\n    stop(\"the 'url_file_string' parameter should be of type character string\", call. = F)\n  }\n\n  if (substring(url_file_string, 1, 4) == \"http\") {       # only url-addresses which start with 'http' will be considered as valid\n\n    con = url(url_file_string, method = \"libcurl\")        # test url-output with : 'https://raw.githubusercontent.com/lyzidiamond/learn-geojson/master/geojson/cupcakes.geojson'\n\n    url_json = readLines(con, warn = FALSE)\n\n    url_file_string = paste(url_json, collapse = \"\\n\")\n\n    rm(con); gc()\n  }\n\n  res = export_From_geojson(url_file_string, ...)\n\n  return(res)\n}\n\n\n\n#' returns a json-dump from a geojson file\n#'\n#' @param url_file either a string specifying the input path to a file OR a valid url (beginning with 'http..') pointing to a geojson object\n#' @return a character string (json dump)\n#' @export\n#' @examples\n#'\n#' library(geojsonR)\n#'\n#' # Do not run\n#'\n#' # res = Dump_From_GeoJson(\"/myfolder/point.geojson\")\n#'\n\nDump_From_GeoJson = function(url_file) {\n\n  if (!inherits(url_file, 'character') && length(url_file) != 1) {\n\n    stop(\"the 'url_file' parameter should be of type character string\", call. = F)\n  }\n\n  if (substring(url_file, 1, 4) == \"http\") {       # only url-addresses which start with 'http' will be considered as valid\n\n    con = url(url_file, method = \"libcurl\")        # test url-output with : 'https://raw.githubusercontent.com/lyzidiamond/learn-geojson/master/geojson/hackspots.geojson'\n\n    url_json = readLines(con, warn = FALSE)\n\n    res = paste(url_json, collapse = \"\\n\")\n\n    rm(con); gc()}\n\n  else if (file.exists(url_file)) {\n\n    res = dump_geojson(url_file)}\n\n  else {\n\n    stop(\"the input shoud be either a valid url (beginning with 'http..') OR a valid path to a geojson file\", call. = F)\n  }\n\n  return(res)\n}\n\n\n\n#' converts data to a GeoJson object\n#'\n#' @param data a list specifying the geojson geometry object\n#' @param stringify either TRUE or FALSE, specifying if the output should also include a geojson-dump (as a character string)\n#' @return a List\n#' @export\n#' @docType class\n#' @importFrom R6 R6Class\n#' @section Methods:\n#'\n#' \\describe{\n#'  \\item{\\code{TO_GeoJson$new()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Point(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{MultiPoint(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{LineString(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{MultiLineString(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Polygon(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{MultiPolygon(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{GeometryCollection(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Feature(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{FeatureCollection(data, stringify = FALSE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'  }\n#'\n#' @usage # utl <- TO_GeoJson$new()\n#' @examples\n#'\n#' library(geojsonR)\n#'\n#'\n#'# initialize class\n#'\n#' init = TO_GeoJson$new()\n#'\n#'\n#' # Examples covering all geometry-objects\n#'\n#'\n#' # Point\n#'\n#' point_dat = c(100, 1.01)\n#'\n#' point = init$Point(point_dat, stringify = TRUE)\n#' point\n#'\n#'\n#' # MultiPoint\n#'\n#' multi_point_dat = list(c(100, 1.01), c(200, 2.01))\n#'\n#' multi_point = init$MultiPoint(multi_point_dat, stringify = TRUE)\n#' multi_point\n#'\n#'\n#' # LineString\n#'\n#' linestring_dat = list(c(100, 1.01), c(200, 2.01))\n#'\n#' line_string = init$LineString(linestring_dat, stringify = TRUE)\n#' line_string\n#'\n#'\n#' # MultiLineString\n#'\n#' multilinestring_dat = list(list(c(100, 0.0), c(101, 1.0)), list(c(102, 2.0), c(103, 3.0)))\n#'\n#' multiline_string = init$MultiLineString(multilinestring_dat, stringify = TRUE)\n#' multiline_string\n#'\n#'\n#' # Polygon (WITHOUT interior rings)\n#'\n#' polygon_WITHOUT_dat = list(list(c(100, 1.01), c(200, 2.01), c(100, 1.0), c(100, 1.01)))\n#'\n#' polygon_without = init$Polygon(polygon_WITHOUT_dat, stringify = TRUE)\n#' polygon_without\n#'\n#'\n#' # Polygon (WITH interior rings)\n#'\n#' polygon_WITH_dat = list(list(c(100, 1.01), c(200, 2.01), c(100, 1.0), c(100, 1.01)),\n#'\n#'                    list(c(50, 0.5), c(50, 0.8), c(50, 0.9), c(50, 0.5)))\n#'\n#' polygon_with = init$Polygon(polygon_WITH_dat, stringify = TRUE)\n#' polygon_with\n#'\n#'\n#' # MultiPolygon\n#'\n#' # the first polygon is without interior rings and the second one is with interior rings\n#'\n#' multi_polygon_dat = list(list(list(c(102, 2.0), c(103, 2.0), c(103, 3.0), c(102, 2.0))),\n#'\n#'                          list(list(c(100, 0.0), c(101, 1.0), c(101, 1.0), c(100, 0.0)),\n#'\n#'                               list(c(100.2, 0.2), c(100.2, 0.8), c(100.8, 0.8), c(100.2, 0.2))))\n#'\n#' multi_polygon = init$MultiPolygon(multi_polygon_dat, stringify = TRUE)\n#' multi_polygon\n#'\n#'\n#'\n#' # GeometryCollection (named list)\n#'\n#'\n#' Point = c(100, 1.01)\n#'\n#' MultiPoint = list(c(100, 1.01), c(200, 2.01))\n#'\n#' MultiLineString = list(list(c(100, 0.0), c(101, 1.0)),\n#'\n#'                   list(c(102, 2.0), c(103, 3.0)))\n#'\n#' LineString = list(c(100, 1.01), c(200, 2.01))\n#'\n#' MultiLineString = list(list(c(100, 0.0), c(101, 1.0)),\n#'\n#'                   list(c(102, 2.0), c(103, 3.0)))\n#'\n#' Polygon = list(list(c(100, 1.01), c(200, 2.01), c(100, 1.0), c(100, 1.01)))\n#'\n#' Polygon = list(list(c(100, 1.01), c(200, 2.01), c(100, 1.0), c(100, 1.01)),\n#'\n#'                list(c(50, 0.5), c(50, 0.8), c(50, 0.9), c(50, 0.5)))\n#'\n#' MultiPolygon = list(list(list(c(102, 2.0), c(103, 2.0), c(103, 3.0), c(102, 2.0))),\n#'\n#'                     list(list(c(100, 0.0), c(101, 1.0), c(101, 1.0), c(100, 0.0)),\n#'\n#'                     list(c(100.2, 0.2), c(100.2, 0.8), c(100.8, 0.8), c(100.2, 0.2))))\n#'\n#'\n#' geometry_collection_dat = list(Point = Point, MultiPoint = MultiPoint,\n#'\n#'                                MultiLineString = MultiLineString, LineString = LineString,\n#'\n#'                                MultiLineString = MultiLineString, Polygon = Polygon,\n#'\n#'                                Polygon = Polygon, MultiPolygon = MultiPolygon)\n#'\n#'\n#' geometry_col = init$GeometryCollection(geometry_collection_dat, stringify = TRUE)\n#' geometry_col\n#'\n#'\n#' # Feature (named list)\n#'\n#'\n#' # Empty 'properties' list\n#'\n#' feature_dat1 = list(id = 1, bbox = c(1,2,3,4), geometry = list(Point = c(100, 1.01)),\n#'\n#'                     properties = list())\n#'\n#'\n#' # Nested 'properties' list\n#'\n#' feature_dat2 = list(id = \"1\", bbox = c(1,2,3,4), geometry = list(Point = c(100, 1.01)),\n#'\n#'                     properties = list(prop0 = 'value0',\n#'\n#'                                       prop1 = 0.0, vec = c(1,2,3), lst = list(a = 1, d = 2)))\n#'\n#'\n#' feature_obj = init$Feature(feature_dat2, stringify = TRUE)\n#' feature_obj\n#' cat(feature_obj$json_dump)\n#'\n#'\n#'\n#' # FeatureCollection (named list)\n#'\n#'\n#' # takes as input the previously created 'feature_dat1', 'feature_dat2'\n#'\n#' feature_col_dat = list(bbox = c(-10.01, -10.01, 10.01, 10.01),\n#'\n#'                        features = list(Feature = feature_dat1, Feature = feature_dat2))\n#' feature_col_dat\n#'\n#'\n#' feature_collection_obj = init$FeatureCollection(feature_col_dat, stringify = TRUE)\n#' feature_collection_obj\n#' cat(feature_collection_obj$json_dump)\n#'\n\nTO_GeoJson <- R6::R6Class(\"TO_GeoJson\",\n\n                              public = list(\n\n                                initialize = function() {\n\n                                  private$empty_vec = numeric(0)\n\n                                },\n\n                                Point = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, c('numeric', 'vector'))) { stop(\"the 'data' parameter should be a numeric vector\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  res = export_To_GeoJson(\"Point\", data, private$empty_vec, private$empty_vec, private$empty_vec, stringify)\n\n                                  return(res)\n                                },\n\n                                MultiPoint = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, c('numeric', 'list'))) { stop(\"the 'data' parameter should be a numeric list\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  res = export_To_GeoJson(\"MultiPoint\", private$empty_vec, data, private$empty_vec, private$empty_vec, stringify)\n\n                                  return(res)\n                                },\n\n                                LineString = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, c('numeric', 'list'))) { stop(\"the 'data' parameter should be a numeric list\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  res = export_To_GeoJson(\"LineString\", private$empty_vec, data, private$empty_vec, private$empty_vec, stringify)\n\n                                  return(res)\n                                },\n\n                                MultiLineString = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, c('numeric', 'list'))) { stop(\"the 'data' parameter should be a numeric list\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  res = export_To_GeoJson(\"MultiLineString\", private$empty_vec, private$empty_vec, data, private$empty_vec, stringify)\n\n                                  return(res)\n                                },\n\n                                Polygon = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, c('numeric', 'list'))) { stop(\"the 'data' parameter should be a numeric list\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  res = export_To_GeoJson(\"Polygon\", private$empty_vec, private$empty_vec, data, private$empty_vec, stringify)\n\n                                  return(res)\n                                },\n\n                                MultiPolygon = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, c('numeric', 'list'))) { stop(\"the 'data' parameter should be a numeric list\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  res = export_To_GeoJson(\"MultiPolygon\", private$empty_vec, private$empty_vec, private$empty_vec, data, stringify)\n\n                                  return(res)\n                                },\n\n                                GeometryCollection = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, c('numeric', 'list'))) { stop(\"the 'data' parameter should be a numeric list\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  geometry_names = names(data)\n\n                                  res = Geom_Collection(geometry_names, data, stringify)\n\n                                  return(res)\n                                },\n\n                                Feature = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, 'list')) { stop(\"the 'data' parameter should be of type list\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  feature_names = names(data)\n\n                                  res = Feature_Obj(feature_names, data, stringify)\n\n                                  return(res)\n                                },\n\n                                FeatureCollection = function(data, stringify = FALSE) {\n\n                                  if (!inherits(data, 'list')) { stop(\"the 'data' parameter should be of type list\", call. = F) }\n\n                                  if (!inherits(stringify, 'logical')) { stop(\"the 'stringify' parameter should be of type boolean\", call. = F) }\n\n                                  feature_col_names = names(data)\n\n                                  res = Feature_collection_Obj(feature_col_names, data, stringify)\n\n                                  return(res)\n                                }\n                              ),\n\n                              private = list(\n\n                                empty_vec = NULL\n                              )\n)\n\n\n\n#' creates a FeatureCollection dump from multiple Feature geojson objects\n#'\n#' @param Features_files_vec a character vector specifying paths to files (Feature geojson objects)\n#' @param bbox_vec either NULL or a numeric vector\n#' @return a FeatureCollection dump\n#' @export\n#' @examples\n#'\n#' library(geojsonR)\n#'\n#' # Do not run\n#'\n#' # vec_files = c(\"/myfolder/Feature1.geojson\", \"/myfolder/Feature2.geojson\",\n#' #               \"/myfolder/Feature3.geojson\", \"/myfolder/Feature4.geojson\",\n#' #               \"/myfolder/Feature5.geojson\")\n#'\n#' # res = Features_2Collection(vec_files, bbox_vec = NULL)\n#'\n\nFeatures_2Collection = function(Features_files_vec, bbox_vec = NULL) {\n\n  if (!inherits(Features_files_vec, c('vector', 'character'))) {\n\n    stop(\"the 'Features_files_vec' parameter should be a character vector\", call. = F)\n  }\n\n  if (is.null(bbox_vec)) {\n\n    bbox_vec = numeric(0)}\n\n  else {\n\n    if (!inherits(bbox_vec, c('vector', 'numeric'))) {\n\n      stop(\"the 'bbox' parameter should be a numeric vector\", call. = F)\n    }\n  }\n\n  tmp_feat = Features_TO_Collection(Features_files_vec, bbox_vec)\n\n  return(tmp_feat)\n}\n\n\n\n\n#' secondary function for shiny Applications\n#'\n#' @param input_file a character string specifying a path to a file\n#' @return a (nested) list\n#' @details\n#' This function is meant for \\emph{shiny Applications}. To read a GeoJson file use the \\emph{FROM_GeoJson} function.\n#' @export\n\nshiny_from_JSON = function(input_file) {              # shiny apps should be in a separate package if Rcpp::class(es) are present\n\n  if (!inherits(input_file, 'character') && length(input_file) != 1) {\n\n    stop(\"the 'input_file' parameter should be a character string\", call. = F)\n  }\n\n  return(export_From_JSON(input_file))\n}\n\n\n",
    "created" : 1490711793872.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1133777207",
    "id" : "2A6186E",
    "lastKnownWriteTime" : 1490724072,
    "last_content_update" : 1490724072657,
    "path" : "~/Desktop/kaggle_gpu/add_GITHUB/geojsonR/R/utils.R",
    "project_path" : "R/utils.R",
    "properties" : {
        "docOutlineSize" : "198.15543797624005",
        "docOutlineVisible" : "1",
        "tempName" : "Untitled1"
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}